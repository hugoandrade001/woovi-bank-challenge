"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const constants_1 = require("./constants");
const utils_1 = require("./utils");
const validOperators = ['gt', 'gte', 'lt', 'lte', 'in', 'nin', 'ne', 'all'];
const arrayOperators = ['in', 'nin', 'all'];
const getFilterName = (filterName) => filterName.split('_')[0];
const handleAndOr = (operator) => (context, condition, mapping) => {
    if (!Array.isArray(condition)) {
        throw new Error(`Invalid filter supplied to ${operator}.`);
    }
    return {
        condition: condition.map((andCondition) => buildConditionsObject(context, andCondition, mapping)),
        conditionName: operator,
    };
};
const handleAnd = handleAndOr('$and');
const handleOr = handleAndOr('$or');
const handleFieldOperator = (_context, condition, conditionName, fieldMapping, prev) => {
    // { "myField_operator": "something" } becomes { "myField": { $operator: "something" } }
    // { "myField": "something" } remains the same
    const conditionNamePieces = conditionName.split('_');
    const operator = conditionNamePieces.length > 1 ? conditionNamePieces.pop() : '';
    // I don't think we support snake case for field names, should this be here?
    conditionName = conditionNamePieces.join('_');
    if (((0, utils_1.isMatchFilterMapping)(fieldMapping) || (0, utils_1.isCustomFilterMapping)(fieldMapping)) &&
        typeof fieldMapping.format === 'function') {
        condition = fieldMapping.format(condition);
    }
    if (operator) {
        if (validOperators.indexOf(operator) === -1) {
            throw new Error(`"${operator}" is not a valid operator on field "${conditionName}".`);
        }
        if (arrayOperators.indexOf(operator) >= 0 && !Array.isArray(condition)) {
            throw new Error(`Field "${conditionName}" must have an array value.`);
        }
        // eslint-disable-next-line
        condition = {
            [`$${operator}`]: condition,
        };
    }
    // handle $gte and $let fields merge
    if (conditionName in prev) {
        // eslint-disable-next-line
        condition = Object.assign(Object.assign({}, condition), prev[conditionName]);
    }
    return {
        condition,
        conditionName,
    };
};
function buildConditionsObject(context, conditions, mapping) {
    return Object.keys(conditions).reduce((prev, currentKey) => {
        let condition = conditions[currentKey];
        let conditionName = currentKey;
        const fieldMapping = mapping[getFilterName(currentKey)];
        if (fieldMapping === false)
            return prev;
        if (fieldMapping && !(0, utils_1.isCustomFilterMapping)(fieldMapping) && !(0, utils_1.isMatchFilterMapping)(fieldMapping)) {
            return prev;
        }
        if (conditionName === 'AND') {
            ({ condition, conditionName } = handleAnd(context, condition, mapping));
        }
        else if (conditionName === 'OR') {
            ({ condition, conditionName } = handleOr(context, condition, mapping));
        }
        else {
            if ((0, utils_1.isCustomFilterMapping)(fieldMapping)) {
                if (fieldMapping.format && typeof fieldMapping.format === 'function') {
                    const customCondition = fieldMapping.format(condition);
                    return Object.assign(Object.assign({}, prev), customCondition);
                }
            }
            ({ condition, conditionName } = handleFieldOperator(context, condition, conditionName, fieldMapping, prev));
        }
        conditionName = (0, utils_1.isMatchFilterMapping)(fieldMapping) && fieldMapping.key ? fieldMapping.key : conditionName;
        return Object.assign(Object.assign({}, prev), { [conditionName]: condition });
    }, {});
}
function buildMongoConditionsFromFilters(context, filters = {}, mapping = {}) {
    if (!filters)
        return { conditions: {}, pipeline: [] };
    const keys = Object.keys(filters);
    // first check if there are any pipeline mapped fields
    //  and if AND or OR are also passed, if that is the case, we must throw an error
    //  because we cannot use OR/AND while also using pipeline.
    const hasPipelineFilter = keys.find((key) => (0, utils_1.isPipelineFilterMapping)(mapping[key]));
    if (hasPipelineFilter && (filters.AND || filters.OR)) {
        throw new Error(`Wrong filter usage, because filter "${hasPipelineFilter}" is a pipeline filter, which should disable AND and OR`);
    }
    // separate filters by type
    const filtersKeysGrouped = Object.keys(filters).reduce((prev, key) => {
        const filterName = getFilterName(key);
        // @ts-ignore
        const type = (mapping && !!mapping[filterName] && mapping[filterName].type) || constants_1.FILTER_CONDITION_TYPE.MATCH_1_TO_1;
        return Object.assign(Object.assign({}, prev), { [type]: Object.assign(Object.assign({}, prev[type]), { [key]: filters[key] }) });
    }, {
        // start with sane defaults
        [constants_1.FILTER_CONDITION_TYPE.MATCH_1_TO_1]: {},
        [constants_1.FILTER_CONDITION_TYPE.CUSTOM_CONDITION]: {},
        [constants_1.FILTER_CONDITION_TYPE.AGGREGATE_PIPELINE]: {},
    });
    // first build our conditions object.
    const conditions = buildConditionsObject(context, Object.assign(Object.assign({}, filtersKeysGrouped.MATCH_1_TO_1), filtersKeysGrouped.CUSTOM_CONDITION), mapping);
    // now build the pipeline, which is more straightforward
    const pipeline = Object.keys(filtersKeysGrouped.AGGREGATE_PIPELINE).reduce((prev, key) => {
        const mappedFilter = mapping[key];
        // should not really happen!
        if (!(0, utils_1.isPipelineFilterMapping)(mappedFilter)) {
            return prev;
        }
        const fieldPipeline = Array.isArray(mappedFilter.pipeline)
            ? mappedFilter.pipeline
            : mappedFilter.pipeline(filters[key]);
        return [...prev, ...fieldPipeline];
    }, []);
    return {
        conditions,
        pipeline,
    };
}
exports.default = buildMongoConditionsFromFilters;
//# sourceMappingURL=buildMongoConditionsFromFilters.js.map