"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createLoader = void 0;
// eslint-disable-next-line
const graphql_mongoose_loader_1 = require("@entria/graphql-mongoose-loader");
const dataloader_1 = __importDefault(require("dataloader"));
const buildMongoConditionsFromFilters_1 = __importDefault(require("./buildMongoConditionsFromFilters"));
const validateContextUser_1 = require("./validateContextUser");
const withConnectionAggregate_1 = require("./withConnectionAggregate");
const withConnectionCursor_1 = require("./withConnectionCursor");
const defaultViewerCanSee = (_context, data) => data;
const createLoader = ({ model, viewerCanSee = defaultViewerCanSee, loaderName, filterMapping = {}, isAggregate = false, shouldValidateContextUser = false, defaultFilters = {}, defaultConditions = {}, defaultSort = { createdAt: -1 }, }) => {
    class Loader {
        constructor(data) {
            // TODO - improve this - get only model paths
            // eslint-disable-next-line
            Object.keys(data).map((key) => {
                this[key] = data[key];
            });
            this.id = data.id || data._id;
        }
    }
    const nameIt = (name, cls) => ({ [name]: class extends cls {
        } }[name]);
    const Wrapper = nameIt(model.collection.collectionName, Loader);
    const getLoader = () => new dataloader_1.default((ids) => (0, graphql_mongoose_loader_1.mongooseLoader)(model, ids));
    const load = async (context, id) => {
        if (!id) {
            return null;
        }
        try {
            const data = await context.dataloaders[loaderName].load(id.toString());
            if (!data) {
                return null;
            }
            const filteredData = await viewerCanSee(context, data);
            return filteredData ? new Wrapper(filteredData) : null;
        }
        catch (err) {
            return null;
        }
    };
    const clearCache = ({ dataloaders }, id) => dataloaders[loaderName].clear(id.toString());
    const primeCache = ({ dataloaders }, id, data) => dataloaders[loaderName].prime(id.toString(), data);
    const clearAndPrimeCache = (context, id, data) => clearCache(context, id) && primeCache(context, id, data);
    const buildFiltersConditionsAndSort = (context, args) => {
        const mongoDefaultFilters = typeof defaultFilters === 'object' ? defaultFilters : defaultFilters(context, args);
        const builtMongoConditions = (0, buildMongoConditionsFromFilters_1.default)(context, Object.assign(Object.assign({}, mongoDefaultFilters), (args.filters ? Object.assign({}, args.filters) : {})), filterMapping);
        const mongoDefaultConditions = typeof defaultConditions === 'object' ? defaultConditions : defaultConditions(context, args);
        const mongoDefaultSort = typeof defaultSort === 'object' ? defaultSort : defaultSort(context, args);
        const conditions = Object.assign(Object.assign({}, mongoDefaultConditions), builtMongoConditions.conditions);
        return {
            builtMongoConditions,
            mongoDefaultConditions,
            conditions,
            mongoDefaultSort,
        };
    };
    const loadAll = isAggregate
        ? (0, withConnectionAggregate_1.withConnectionAggregate)(model, load, (context, args) => {
            const { mongoDefaultConditions, builtMongoConditions } = buildFiltersConditionsAndSort(context, args);
            return {
                defaultConditions: mongoDefaultConditions,
                builtMongoConditions,
            };
        })
        : (0, withConnectionCursor_1.withConnectionCursor)(model, load, (context, args) => {
            const { conditions, mongoDefaultSort } = buildFiltersConditionsAndSort(context, args);
            return {
                conditions,
                sort: mongoDefaultSort,
            };
        });
    return {
        Wrapper: Wrapper,
        getLoader,
        clearCache,
        primeCache,
        clearAndPrimeCache,
        load,
        loadAll: shouldValidateContextUser ? (0, validateContextUser_1.validateContextUser)(loadAll) : loadAll,
    };
};
exports.createLoader = createLoader;
//# sourceMappingURL=createLoader.js.map